<html>

<head>
<title>WebGPU test-4</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
#version 450
layout(location = 0)
out vec4 vColor;
void main() {
    switch(gl_VertexIndex) {
        case 0: gl_Position = vec4(-0.5, -0.5, 0.0, 1.0); break;
        case 1: gl_Position = vec4(+0.5, -0.5, 0.0, 1.0); break;
        case 2: gl_Position = vec4(+0.0, +0.7, 0.0, 1.0); break;
    }
    vColor = gl_Position * 0.5 + 0.5;
}
</script>
<script id="shader-fs" type="x-shader/x-fragment">
#version 450
layout(location = 0)
in vec4 vColor;
layout(location = 0)
out vec4 oColor;
void main() {
    oColor = vColor;
}
</script>

<script type="text/javascript">
    var gpu;
    var red = 0.0;

    function webGpuStart() {
        let canvas = document.getElementById("test-canvas");
        let context = canvas.getContext("experimental-webgpu");
        if (!context) {
            alert("Could not initialise WebGPU, sorry :-(");
        }

        let adapter = context.enumerateAdapters()[0];
        let queueFamily = adapter
            .getQueueFamilies()
            .find(function(family) {
                return (family.flags & adapter.QUEUE_GENERAL) != 0;
            });

        let webgpu = adapter.open([{ id: queueFamily.id, count: 1 }]);
        let device = webgpu.device;
        let queue = webgpu.generalQueues[0];

        let frameFence = device.createFence(false);
        let swapChain = context.buildSwapchain(queue);

        let renderpass = device.createRenderpass(
            [{
                format: swapChain.format,
                srcLayout: "Undefined",
                dstLayout: "Present",
                loadOp: "Clear",
                storeOp: "Store",
            }],
            [
                [{
                    attachmentId: 0,
                    layout: "ColorAttachmentOptimal",
                }]
            ],
            [{
                srcPass: null,
                dstPass: 0,
                srcStages: device.PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT,
                dstStages: device.PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT,
                srcAccess: 0,
                dstAccess: device.IMAGE_ACCESS_COLOR_ATTACHMENT_READ | device.IMAGE_ACCESS_COLOR_ATTACHMENT_WRITE,
            }]
        );

        let swapSequence = swapChain
            .getImages()
            .map(function(image) {
                let size = swapChain.getSize();
                size.layers = 1;
                let rtv = device.viewImageAsRenderTarget(image, swapChain.format);
                let fbo = device.createFramebuffer(renderpass, size, [rtv], null);
                return { image: image, rtv: rtv, fbo: fbo };
            });

        let commandPool = queue.createCommandPool(0);
        let commandBuffer = commandPool.allocateCommandBuffers(1)[0];

        // Pipeline Layout
        let setLayout = device.createDescriptorSetLayout([
            {
                binding: 0,
                count: 1,
                type: "SampledImage",
                stages: device.SHADER_STAGE_FRAGMENT,
            },
            {
                binding: 1,
                count: 1,
                type: "Sampler",
                stages: device.SHADER_STAGE_FRAGMENT,
            }
        ]);
        let pipelineLayout = device.createPipelineLayout([setLayout]);

        let vsModule = device.createShaderModuleFromGLSL("Vertex",
            document.getElementById("shader-vs").textContent);
        let fsModule = device.createShaderModuleFromGLSL("Fragment",
            document.getElementById("shader-fs").textContent);

        let pipelineDesc = {
            shaders: {
                "vs": { shader_module: vsModule, entry_point: "main" },
                "fs": { shader_module: fsModule, entry_point: "main" },
            },
            inputAssemblyState: {
                topology: "TriangleStrip",
            },
            rasterizerState: {
                polygonMode: "Fill",
                frontFace: "Ccw",
            },
            blendState: {
                targets: [
                    {
                        color: {},
                        alpha: {},
                    }
                ],
            },
            layout: pipelineLayout,
            renderpass: renderpass,
            subpass: 0,
        };
        let pso = device.createGraphicsPipelines([pipelineDesc])[0];

        //Load the image
        let imageCanvas = document.getElementById("image-canvas");
        let imageCtx = imageCanvas.getContext('2d');
        let imageData = imageCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height).data;
        let imageStride = 4;
        let rowAlignmentMask = device.getLimits().minBufferCopyPitchAlignment - 1;
        let imagePitch = imageCanvas.width * imageStride;
        let uploadPitch = (imagePitch + rowAlignmentMask) & ~rowAlignmentMask;
        let uploadSize = uploadPitch * imageCanvas.height;

        // copy image data with alignments into a shared buffer
        let sab = new ArrayBuffer(uploadSize); //TODO: SharedArrayBuffer
        for(let y=0; y<imageCanvas.height; ++y) {
            let target = new Uint8Array(sab, y*uploadPitch, uploadPitch);
            target.set(imageData.subarray(y*imagePitch, (y+1)*imagePitch));
        }

        let uploadHeapType = webgpu.heapTypes.find(function(ht) {
            return (ht.properties & device.HEAP_PROPERTY_CPU_VISIBLE) != 0 &&
                   (ht.properties & device.HEAP_PROPERTY_COHERENT) != 0;
        });
        let uploadHeap = device.createHeap(uploadHeapType.id, "Buffers", uploadSize+0x10000);
        let uploadBufferDesc = {
            size: uploadSize,
            stride: imageStride,
            usage: device.BUFFER_USAGE_TRANSFER_SRC,
        };
        let uploadBuffer = device.createBuffer(uploadBufferDesc, uploadHeap, 0);
        device.uploadBufferData(uploadBuffer, sab);

        let deviceHeapType = webgpu.heapTypes.find(function(ht) {
            return (ht.properties & device.HEAP_PROPERTY_DEVICE_LOCAL) != 0;
        });
        let imageHeap = device.createHeap(deviceHeapType.id, "Images", uploadSize+0x10000); //TODO: size
        let imageDesc = {
            width: imageCanvas.width,
            height: imageCanvas.height,
            format: "R8G8B8A8_SRGB",
            usage: device.IMAGE_USAGE_TRANSFER_DST | device.IMAGE_USAGE_SAMPLED,
        };
        let image = device.createImage(imageDesc, imageHeap, 0);

        // Descriptors
        let descriptorPool = device.createDescriptorPool(1, [
            {
                type: "SampledImage",
                count: 1,
            },
            {
                type: "Sampler",
                count: 1,
            }
        ]);
        let set = descriptorPool.allocateSets([setLayout]);
        /*
        let image_srv = device.view_image_as_shader_resource(&image_logo, ColorFormat::get_format()).unwrap();

        let sampler = device.create_sampler(
            i::SamplerInfo::new(
                i::FilterMethod::Bilinear,
                i::WrapMode::Clamp,
            )
        );

        device.update_descriptor_sets(&[
            pso::DescriptorSetWrite {
                set: &set0[0],
                binding: 0,
                array_offset: 0,
                write: pso::DescriptorWrite::SampledImage(vec![(&image_srv, i::ImageLayout::Undefined)]),
            },
            pso::DescriptorSetWrite {
                set: &set1[0],
                binding: 0,
                array_offset: 0,
                write: pso::DescriptorWrite::Sampler(vec![&sampler]),
            },
        ]);
        */

        gpu = {
            context: context,
            device: device,
            queue: queue, 
            swapChain: swapChain,
            swapSequence: swapSequence,
            graphicsPool: commandPool,
            commandBuffer: commandBuffer,
            frameFence: frameFence,
            renderpass: renderpass,
            pipelineLayout: pipelineLayout,
            pso: pso,
        };

        let extent = {
            width: imageCanvas.width,
            height: imageCanvas.height,
        };
        webGpuInit(uploadBuffer, uploadPitch, image, extent);

        setInterval(webGpuRender, 60);
    }

    function webGpuInit(uploadBuffer, bufferPitch, image, extent) {
        let dev = gpu.device;
        let cb = gpu.commandBuffer;
        cb.begin();

        let imageBarrierBefore = {
            stateSrc: {
                access: 0,
                layout: "Undefined",
            },
            stateDst: {
                access: dev.IMAGE_ACCESS_TRANSFER_WRITE,
                layout: "TransferDstOptimal",
            },
            target: image,
        };
        cb.pipelineBarrier(
            dev.PIPELINE_STAGE_TOP_OF_PIPE,
            dev.PIPELINE_STAGE_TRANSFER,
            [], [imageBarrierBefore]
        );

        cb.copyBufferToImage(uploadBuffer, image, "TransferDstOptimal", [
            {
                bufferOffset: 0,
                bufferRowPitch: bufferPitch,
                bufferSlicePitch: bufferPitch * extent.height,
                imageOffset: {},
                imageExtent: extent,
            }
        ]);

        let imageBarrierAfter = {
            stateSrc: {
                access: dev.IMAGE_ACCESS_TRANSFER_WRITE,
                layout: "TransferDstOptimal",
            },
            stateDst: {
                access: dev.IMAGE_ACCESS_SHADER_READ,
                layout: "ShaderReadOnlyOptimal",
            },
            target: image,
        };
        cb.pipelineBarrier(
            dev.PIPELINE_STAGE_TRANSFER,
            dev.PIPELINE_STAGE_FRAGMENT_SHADER,
            [], [imageBarrierAfter]
        );

        cb.finish();
        gpu.queue.submit([cb], [], [], gpu.frameFence);
    }

    function webGpuRender() {
        gpu.device.waitForFences([gpu.frameFence], "All", 100000);
        gpu.device.resetFences([gpu.frameFence]);
        gpu.graphicsPool.reset();

        let frameId = gpu.swapChain.acquireNextImage(null);
        let frame = gpu.swapSequence[frameId];
        let cb = gpu.commandBuffer;
        cb.begin();

        let size = gpu.swapChain.getSize();
        let rect = {
            x: 0,
            y: 0,
            width: size.width,
            height: size.height,
        };
        let clearValue = {
            kind: "ColorFloat",
            data: [red, 0.2, 0.3, 1.0],
        };
        cb.beginRenderpass(gpu.renderpass, frame.fbo, rect, [clearValue]);
        cb.bindGraphicsPipeline(gpu.pso);
        cb.setScissors([rect]);
        cb.setViewports([{ rect: rect, near: 0.0, far: 1.0 }]);
        cb.draw(0, 3, 0, 1)
        cb.endRenderpass();

        cb.finish();
        gpu.queue.submit([cb], [], [], gpu.frameFence);
        //wait_semaphores: &[(&mut frame_semaphore, pso::BOTTOM_OF_PIPE)],

        gpu.swapChain.present();

        red += 0.01;
        if (red >= 1.0) red -= 1.0;
    }
</script>

</head>
<body onload="webGpuStart();">
<canvas id="test-canvas" style="border: none;" width="720" height="400"></canvas>
<canvas id="image-canvas" style="display: none">
    <img src="gfx-logo.png"/>
</canvas>
</body>
</html>
