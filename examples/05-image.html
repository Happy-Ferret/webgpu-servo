<html>

<head>
<title>WebGPU test-4</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
#version 450
layout(location = 0)
out vec4 vColor;
void main() {
    switch(gl_VertexIndex) {
        case 0: gl_Position = vec4(-0.5, -0.5, 0.0, 1.0); break;
        case 1: gl_Position = vec4(+0.5, -0.5, 0.0, 1.0); break;
        case 2: gl_Position = vec4(+0.0, +0.7, 0.0, 1.0); break;
    }
    vColor = gl_Position * 0.5 + 0.5;
}
</script>
<script id="shader-fs" type="x-shader/x-fragment">
#version 450
layout(location = 0)
in vec4 vColor;
layout(location = 0)
out vec4 oColor;
void main() {
    oColor = vColor;
}
</script>

<script type="text/javascript">
    var gpu;
    var red = 0.0;

    function webGpuStart() {
        var canvas = document.getElementById("test-canvas");
        var context = canvas.getContext("experimental-webgpu");
        if (!context) {
            alert("Could not initialise WebGPU, sorry :-(");
        }

        var adapter = context.enumerateAdapters()[0];
        var queueFamily = adapter
            .getQueueFamilies()
            .find(function(family) {
                return (family.flags & adapter.QUEUE_GENERAL) != 0;
            });

        var device = adapter.open([{ id: queueFamily.id, count: 1 }]);
        var queue = device.generalQueue; //TODO: generalQueues[0]
        var frameFence = device.createFence(false);

        var swapChain = context.buildSwapchain(queue);

        var renderpass = device.createRenderpass(
            [{
                format: swapChain.format,
                srcLayout: "Undefined",
                dstLayout: "Present",
                loadOp: "Clear",
                storeOp: "Store",
            }],
            [
                [{
                    attachmentId: 0,
                    layout: "ColorAttachmentOptimal",
                }]
            ],
            [{
                srcPass: null,
                dstPass: 0,
                srcStages: device.PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT,
                dstStages: device.PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT,
                srcAccess: 0,
                dstAccess: device.ACCESS_COLOR_ATTACHMENT_READ | device.ACCESS_COLOR_ATTACHMENT_WRITE,
            }]
        );

        var swapSequence = swapChain
            .getImages()
            .map(function(image) {
                var size = swapChain.getSize();
                size.layers = 1;
                let rtv = device.viewImageAsRenderTarget(image, swapChain.format);
                let fbo = device.createFramebuffer(renderpass, size, [rtv], null);
                return { image: image, rtv: rtv, fbo: fbo };
            });

        var commandPool = queue.createCommandPool(0);
        var commandBuffer = commandPool.allocateCommandBuffers(1)[0];

        /*// Pipeline Layout
        let set0_layout = device.create_descriptor_set_layout(&[
                pso::DescriptorSetLayoutBinding {
                    binding: 0,
                    ty: pso::DescriptorType::SampledImage,
                    count: 1,
                    stage_flags: pso::STAGE_FRAGMENT,
                }
            ],
        );

        let set1_layout = device.create_descriptor_set_layout(&[
                pso::DescriptorSetLayoutBinding {
                    binding: 0,
                    ty: pso::DescriptorType::Sampler,
                    count: 1,
                    stage_flags: pso::STAGE_FRAGMENT,
                }
            ],
        );*/

        var pipelineLayout = device.createPipelineLayout([]);

        /*// Descriptors
            let mut srv_pool = device.create_descriptor_pool(
                1, // sets
                &[pso::DescriptorRangeDesc { ty: pso::DescriptorType::SampledImage, count: 1 }],
            );
            let set0 = srv_pool.allocate_sets(&[&set0_layout]);

            let mut sampler_pool = device.create_descriptor_pool(
                1, // sets
                &[pso::DescriptorRangeDesc { ty: pso::DescriptorType::Sampler, count: 1 }],
            );
            let set1 = sampler_pool.allocate_sets(&[&set1_layout]);
        */

        let vsModule = device.createShaderModuleFromGLSL("Vertex",
            document.getElementById("shader-vs").textContent);
        let fsModule = device.createShaderModuleFromGLSL("Fragment",
            document.getElementById("shader-fs").textContent);

        let pipelineDesc = {
            shaders: {
                "vs": { shader_module: vsModule, entry_point: "main" },
                "fs": { shader_module: fsModule, entry_point: "main" },
            },
            inputAssemblyState: {
                topology: "TriangleStrip",
            },
            rasterizerState: {
                polygonMode: "Fill",
                frontFace: "Ccw",
            },
            blendState: {
                targets: [
                    {
                        color: {},
                        alpha: {},
                    }
                ],
            },
            layout: pipelineLayout,
            renderpass: renderpass,
            subpass: 0,
        };
        let pso = device.createGraphicsPipelines([pipelineDesc])[0];

        /*//Load the image
        let upload_heap =
            heap_types.iter().find(|&&heap_type| {
                heap_type.properties.contains(m::CPU_VISIBLE | m::COHERENT)
            })
            .unwrap();
        let image_upload_heap = device.create_heap(upload_heap, d::ResourceHeapType::Buffers, upload_size).unwrap();
        let image_upload_buffer = {
            let buffer = device.create_buffer(upload_size, image_stride as u64, buffer::TRANSFER_SRC).unwrap();
            device.bind_buffer_memory(&image_upload_heap, 0, buffer).unwrap()
        };

        // copy image data into staging buffer
        if let Ok(mut mapping) = device.write_mapping::<u8>(&image_upload_buffer, 0..upload_size) {
            for y in 0 .. height as usize {
                let row = &(*img)[y*(width as usize)*image_stride .. (y+1)*(width as usize)*image_stride];
                let dest_base = y * row_pitch as usize;
                mapping[dest_base .. dest_base + row.len()].copy_from_slice(row);
            }
        }

        let image = device.create_image(kind, 1, ColorFormat::get_format(), i::TRANSFER_DST | i::SAMPLED).unwrap(); // TODO: usage
        println!("{:?}", image);
        let image_req = device.get_image_requirements(&image);

        let device_heap = heap_types.iter().find(|&&heap_type| heap_type.properties.contains(m::DEVICE_LOCAL)).unwrap();
        let image_heap = device.create_heap(device_heap, d::ResourceHeapType::Images, image_req.size).unwrap();

        let image_logo = device.bind_image_memory(&image_heap, 0, image).unwrap();
        let image_srv = device.view_image_as_shader_resource(&image_logo, ColorFormat::get_format()).unwrap();

        let sampler = device.create_sampler(
            i::SamplerInfo::new(
                i::FilterMethod::Bilinear,
                i::WrapMode::Clamp,
            )
        );

        device.update_descriptor_sets(&[
            pso::DescriptorSetWrite {
                set: &set0[0],
                binding: 0,
                array_offset: 0,
                write: pso::DescriptorWrite::SampledImage(vec![(&image_srv, i::ImageLayout::Undefined)]),
            },
            pso::DescriptorSetWrite {
                set: &set1[0],
                binding: 0,
                array_offset: 0,
                write: pso::DescriptorWrite::Sampler(vec![&sampler]),
            },
        ]);
        */

        gpu = {
            context: context,
            device: device,
            queue: queue, 
            swapChain: swapChain,
            swapSequence: swapSequence,
            graphicsPool: commandPool,
            commandBuffer: commandBuffer,
            frameFence: frameFence,
            renderpass: renderpass,
            pipelineLayout: pipelineLayout,
            pso: pso,
        };

        setInterval(webGpuRender, 60);
    }

    function webGpuRender() {
        gpu.device.resetFences([gpu.frameFence]);
        gpu.graphicsPool.reset();

        var frameId = gpu.swapChain.acquireNextImage(null);
        var frame = gpu.swapSequence[frameId];
        var cb = gpu.commandBuffer;
        cb.begin();

        var size = gpu.swapChain.getSize();
        var rect = {
            x: 0,
            y: 0,
            width: size.width,
            height: size.height,
        };
        var clearValue = {
            kind: "ColorFloat",
            data: [red, 0.2, 0.3, 1.0],
        };
        cb.beginRenderpass(gpu.renderpass, frame.fbo, rect, [clearValue]);
        cb.bindGraphicsPipeline(gpu.pso);
        cb.setScissors([rect]);
        cb.setViewports([{ rect: rect, near: 0.0, far: 1.0 }]);
        cb.draw(0, 3, 0, 1)
        cb.endRenderpass();

        cb.finish();
        gpu.queue.submit([cb], [], [], gpu.frameFence);
        //wait_semaphores: &[(&mut frame_semaphore, pso::BOTTOM_OF_PIPE)],
        gpu.device.waitForFences([gpu.frameFence], "All", 100000);

        gpu.swapChain.present();

        red += 0.01;
        if (red >= 1.0) red -= 1.0;
    }
</script>
</head>

<body onload="webGpuStart();">
<img src="gfx-logo.html"></img>
<canvas id="test-canvas" style="border: none;" width="720" height="400"></canvas>
</body>
</html>
